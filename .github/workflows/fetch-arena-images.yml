name: Fetch Are.na Images

on:
  schedule:
    # Run every night at 3am UTC
    - cron: '0 3 * * *'
  push:
    branches:
      - master
    paths:
      - '.github/workflows/fetch-arena-images.yml'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  fetch-images:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure ImageMagick is available
        run: |
          sudo apt-get update && sudo apt-get install -y imagemagick webp libwebp-dev libheif-dev libraw-dev librsvg2-bin

      - name: Fetch and process Are.na images
        run: |
          set -e

          CHANNEL_SLUG="dia-phone-slot-machine"
          OUTPUT_DIR="images/Icons"
          ORIGINALS_DIR="images/Icons/originals"
          MAX_WIDTH=150  # 2x retina for 70px display

          mkdir -p "$OUTPUT_DIR"
          mkdir -p "$ORIGINALS_DIR"

          echo "Fetching channel contents from Are.na..."

          # Are.na API paginates, fetch all pages
          PAGE=1
          PER=100
          ALL_URLS=""

          while true; do
            RESPONSE=$(curl -sf "https://api.are.na/v2/channels/${CHANNEL_SLUG}/contents?page=${PAGE}&per=${PER}")

            # Extract display image URLs (preserves aspect ratio, ~800px)
            URLS=$(echo "$RESPONSE" | jq -r '.contents[]? | select(.class == "Image") | .image.display.url // empty')

            if [ -z "$URLS" ]; then
              break
            fi

            ALL_URLS="${ALL_URLS}${URLS}"$'\n'

            # Check if there are more pages
            TOTAL=$(echo "$RESPONSE" | jq -r '.length // 0')
            FETCHED=$((PAGE * PER))
            if [ "$FETCHED" -ge "$TOTAL" ]; then
              break
            fi

            PAGE=$((PAGE + 1))
          done

          # Remove empty lines
          ALL_URLS=$(echo "$ALL_URLS" | sed '/^$/d')

          if [ -z "$ALL_URLS" ]; then
            echo "No images found in channel. Exiting."
            exit 1
          fi

          COUNT=$(echo "$ALL_URLS" | wc -l)
          echo "Found $COUNT images"

          # Clear old images
          rm -f "$OUTPUT_DIR"/image*.jpg
          rm -f "$ORIGINALS_DIR"/image*.jpg

          # Download and resize each image
          INDEX=1
          while IFS= read -r URL; do
            if [ -n "$URL" ]; then
              OUTFILE="$OUTPUT_DIR/image${INDEX}.jpg"
              echo "Downloading image ${INDEX}/${COUNT}..."
              TMPFILE="${OUTFILE}.download"
              curl -sf "$URL" -o "$TMPFILE"

              # Detect actual image format from file contents and use correct extension
              # so ImageMagick can identify the decoder to use
              MIME=$(file --mime-type -b "$TMPFILE")
              EXT="${MIME#image/}"

              if [ "$MIME" = "$EXT" ] || [ -z "$EXT" ]; then
                echo "Skipping image ${INDEX}: not an image (${MIME})"
                rm -f "$TMPFILE"
                continue
              fi

              # Normalize common MIME subtypes to file extensions
              case "$EXT" in
                jpeg)      EXT="jpg" ;;
                svg+xml)   EXT="svg" ;;
                x-icon)    EXT="ico" ;;
                vnd.microsoft.icon) EXT="ico" ;;
              esac

              TYPED_TMP="${OUTFILE}.tmp.${EXT}"
              mv "$TMPFILE" "$TYPED_TMP"

              ORIG_OUTFILE="$ORIGINALS_DIR/image${INDEX}.jpg"

              # Save original-quality version (for high-res side display)
              # Convert to JPEG but keep full resolution
              if convert "${TYPED_TMP}[0]" \
                -quality 90 \
                -strip \
                "$ORIG_OUTFILE"; then
                echo "Saved original image ${INDEX} (${EXT})"
              else
                echo "Warning: Failed to save original image ${INDEX} (${MIME})"
              fi

              # Resize to max width, preserving aspect ratio, compress as JPEG
              # Use [0] to take only the first frame from animated formats (GIF, APNG)
              if convert "${TYPED_TMP}[0]" \
                -resize "${MAX_WIDTH}>" \
                -quality 80 \
                -strip \
                "$OUTFILE"; then
                echo "Converted image ${INDEX} (${EXT})"
                INDEX=$((INDEX + 1))
              else
                echo "Warning: Failed to convert image ${INDEX} (${MIME}), skipping"
                rm -f "$OUTFILE" "$ORIG_OUTFILE"
              fi

              rm -f "$TYPED_TMP"
            fi
          done <<< "$ALL_URLS"

          # Write the count so script.js can pick it up
          FINAL_COUNT=$(ls "$OUTPUT_DIR"/image*.jpg 2>/dev/null | wc -l)
          echo "{\"count\": ${FINAL_COUNT}}" > "$OUTPUT_DIR/manifest.json"
          echo "Processed $FINAL_COUNT images"

      - name: Check for changes
        id: changes
        run: |
          git add images/Icons/ images/Icons/originals/
          if git diff --staged --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit and push
        if: steps.changes.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "Update icons from Are.na channel"
          git pull --rebase origin master
          git push
